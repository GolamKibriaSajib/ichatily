'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _events = require('events');

var _nickserv = require('nickserv');

var _nickserv2 = _interopRequireDefault(_nickserv);

var _ircgramppPlugin = require('ircgrampp-plugin');

var _ircgramppPlugin2 = _interopRequireDefault(_ircgramppPlugin);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Indentifier = function (_EventEmitter) {
    _inherits(Indentifier, _EventEmitter);

    function Indentifier(plugInstance, connection, connectionOptions) {
        _classCallCheck(this, Indentifier);

        var _this = _possibleConstructorReturn(this, (Indentifier.__proto__ || Object.getPrototypeOf(Indentifier)).call(this));

        _this._plugin = plugInstance;
        _this._connection = connection;
        _this._identified = false;
        _this._nick = connection.nick;
        _this._config = connectionOptions;
        _this._ts = null;

        _this._ns = new _nickserv2.default(_this._nick, {});

        _this.debug('Attaching identifier to ' + _this._connection.identifier);
        debugger;
        _this._ns.attach('irc', _this._connection.client);

        _this._ns.on('loggedout', function () {
            _this.debug('Logged out, re-identify');
            _this._identified = false;
            _this.identify();
        });

        _this._ns.on('notice', function (notice) {
            _this.debug('Received notice ' + notice);
        });

        _this.identify();
        return _this;
    }

    _createClass(Indentifier, [{
        key: 'identify',
        value: function identify() {
            var _this2 = this;

            if (this._identified) {
                return;
            }

            this.debug('Identifing');

            this._ts = setTimeout(function () {
                _this2.debug('Login timeout');
                throw new Error('Login timeout');
            }, 30000);

            this._ns.once('identified', function () {
                clearTimeout(_this2._ts);
                _this2.debug('Identify success');
                _this2._identified = true;
                _this2.emit('success');
            });

            this._ns.identify(this._config.password, function (err) {
                if (err) {
                    _this2.debug('Error', err);
                    throw err;
                }
            });
        }
    }, {
        key: 'waitForSuccess',
        value: function waitForSuccess() {
            var _this3 = this;

            if (this._identified) {
                return this.Promise.resolve(false);
            }

            return new this.Promise(function (resolve) {
                _this3.debug('Waiting for success');
                _this3.once('success', function () {
                    resolve(true);
                });
            });
        }
    }, {
        key: 'debug',
        get: function get() {
            return this._plugin.debug;
        }
    }, {
        key: 'Promise',
        get: function get() {
            return this._plugin.Promise;
        }
    }, {
        key: 'isIdentified',
        get: function get() {
            return this._identified;
        }
    }]);

    return Indentifier;
}(_events.EventEmitter);

var NickServPlugin = function (_PluginBase) {
    _inherits(NickServPlugin, _PluginBase);

    function NickServPlugin() {
        _classCallCheck(this, NickServPlugin);

        return _possibleConstructorReturn(this, (NickServPlugin.__proto__ || Object.getPrototypeOf(NickServPlugin)).apply(this, arguments));
    }

    _createClass(NickServPlugin, [{
        key: 'initialize',
        value: function initialize() {
            this.debug('NickServ plugin started');
            this._connectionOptions = this.config.get('connections');
            this._autoconnect = false;
        }
    }, {
        key: 'getCompatibleVersion',
        value: function getCompatibleVersion() {
            return "~0.3.0";
        }
    }, {
        key: 'afterIrcconnectionCreate',
        value: function afterIrcconnectionCreate(connection) {
            this.debug('New connection, check if there are options for this');

            var options = connection._options;

            var connectionOptions = this._connectionOptions.find(function (x) {
                return x.server === options.server && x.nick === options.nick;
            });

            if (connectionOptions) {
                this.debug('Options find to ' + options.nick + '@' + options.server);
                connection.__identifier = new Indentifier(this, connection, connectionOptions);
            } else {
                this.debug('Not found, ignoring');
            }

            return options;
        }
    }, {
        key: 'beforeIrcconnectionWaitForRegistered',
        value: function beforeIrcconnectionWaitForRegistered(connection) {
            if (connection.__identifier) {
                return connection.__identifier.waitForSuccess();
            }
        }
    }]);

    return NickServPlugin;
}(_ircgramppPlugin2.default);

exports.default = NickServPlugin;